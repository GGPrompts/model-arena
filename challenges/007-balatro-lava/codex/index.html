<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Balatro Lava â€” Hypnotic Landing</title>
  <style>
    :root {
      --bg: #030306;
      --magenta: #ff2bd6;
      --cyan: #25f6ff;
      --gold: #ffcc33;
      --purple: #8b5bff;
      --text: #f7f2ff;
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: "Trebuchet MS", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      overflow: hidden;
    }

    /* Layered canvases */
    canvas.bg,
    canvas.fx {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
    }

    canvas.bg {
      z-index: 0;
      opacity: 0.9;
      filter: saturate(1.15);
    }

    canvas.fx {
      z-index: 1;
      mix-blend-mode: screen;
      opacity: 0.92;
    }

    /* CRT / glow overlay */
    .crt {
      position: fixed;
      inset: 0;
      z-index: 2;
      pointer-events: none;
      background:
        repeating-linear-gradient(
          to bottom,
          rgba(255,255,255,0.03) 0px,
          rgba(255,255,255,0.03) 1px,
          rgba(0,0,0,0.04) 2px,
          rgba(0,0,0,0.04) 3px
        );
      mix-blend-mode: screen;
      opacity: 0.18;
      animation: crtFlicker 6s steps(120) infinite;
    }

    @keyframes crtFlicker {
      0%, 100% { opacity: 0.16; }
      20% { opacity: 0.22; }
      40% { opacity: 0.14; }
      60% { opacity: 0.2; }
      80% { opacity: 0.17; }
    }

    /* Center UI */
    .center {
      position: relative;
      z-index: 3;
      width: min(1100px, 94vw);
      height: 100vh;
      margin: 0 auto;
      display: grid;
      place-items: center;
      text-align: center;
      padding: 6vh 2rem 10vh;
    }

    .panel {
      padding: clamp(1.5rem, 3vw, 3rem) clamp(1.2rem, 3.5vw, 3.5rem);
      border-radius: 28px;
      background:
        radial-gradient(120% 160% at 10% -10%, rgba(139,91,255,0.12), transparent 55%),
        radial-gradient(120% 160% at 110% 10%, rgba(37,246,255,0.12), transparent 60%),
        rgba(8, 6, 18, 0.48);
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow:
        0 0 0 1px rgba(255,255,255,0.02) inset,
        0 18px 60px rgba(18, 8, 46, 0.65),
        0 0 60px rgba(139,91,255,0.18),
        0 0 120px rgba(37,246,255,0.12);
      backdrop-filter: blur(8px) saturate(1.2);
      -webkit-backdrop-filter: blur(8px) saturate(1.2);
    }

    h1.title {
      margin: 0 0 0.5rem;
      font-size: clamp(3.4rem, 11vw, 9rem);
      letter-spacing: 0.04em;
      text-transform: uppercase;
      line-height: 0.9;
      font-weight: 900;
      position: relative;
      display: inline-block;
      padding: 0.1em 0.12em 0.18em;
      color: transparent;
      background-image:
        linear-gradient(
          120deg,
          var(--magenta),
          var(--purple),
          var(--cyan),
          var(--gold),
          var(--magenta)
        );
      background-size: 300% 300%;
      -webkit-background-clip: text;
      background-clip: text;
      animation:
        rainbowShift 12s linear infinite,
        glowPulse 3.8s ease-in-out infinite;
      text-shadow:
        0 0 6px rgba(255, 43, 214, 0.45),
        0 0 18px rgba(139, 91, 255, 0.4),
        0 0 36px rgba(37, 246, 255, 0.35);
      filter: drop-shadow(0 0 18px rgba(37,246,255,0.2));
    }

    @keyframes rainbowShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    @keyframes glowPulse {
      0%, 100% {
        transform: translateY(0);
        filter: drop-shadow(0 0 10px rgba(255, 43, 214, 0.24))
                drop-shadow(0 0 20px rgba(37, 246, 255, 0.18));
      }
      50% {
        transform: translateY(-2px);
        filter: drop-shadow(0 0 16px rgba(255, 204, 51, 0.35))
                drop-shadow(0 0 30px rgba(139, 91, 255, 0.28));
      }
    }

    .subtitle {
      margin: 0.25rem 0 2rem;
      font-size: clamp(0.95rem, 2.2vw, 1.25rem);
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: rgba(240, 232, 255, 0.82);
      text-shadow: 0 0 16px rgba(139, 91, 255, 0.18);
    }

    nav.menu {
      display: flex;
      gap: clamp(0.6rem, 2.6vw, 2rem);
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
      margin-top: 0.4rem;
      user-select: none;
    }

    .menu a {
      position: relative;
      text-decoration: none;
      color: rgba(255, 243, 200, 0.88);
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      font-size: clamp(0.9rem, 1.8vw, 1.05rem);
      padding: 0.6rem 0.9rem 0.7rem;
      border-radius: 12px;
      transition: color 180ms ease, text-shadow 180ms ease, transform 180ms ease;
      text-shadow:
        0 0 8px rgba(255, 204, 51, 0.35),
        0 0 18px rgba(255, 204, 51, 0.18);
    }

    .menu a::after {
      content: "";
      position: absolute;
      left: 12%;
      right: 12%;
      bottom: 8%;
      height: 2px;
      border-radius: 2px;
      background: linear-gradient(90deg, rgba(255,204,51,0), rgba(255,204,51,1), rgba(255,204,51,0));
      box-shadow:
        0 0 8px rgba(255, 204, 51, 0.8),
        0 0 18px rgba(255, 204, 51, 0.5);
      transform: scaleX(0.35);
      opacity: 0.6;
      transition: transform 220ms ease, opacity 220ms ease;
    }

    .menu a:hover,
    .menu a:focus-visible {
      color: #fff3c4;
      transform: translateY(-1px);
      text-shadow:
        0 0 10px rgba(255, 204, 51, 0.55),
        0 0 24px rgba(255, 204, 51, 0.35),
        0 0 40px rgba(255, 204, 51, 0.22);
      outline: none;
    }

    .menu a:hover::after,
    .menu a:focus-visible::after {
      transform: scaleX(1);
      opacity: 1;
    }

    .menu a.active {
      color: #ffe28a;
      text-shadow:
        0 0 12px rgba(255, 204, 51, 0.7),
        0 0 30px rgba(255, 204, 51, 0.45),
        0 0 60px rgba(255, 204, 51, 0.25);
    }

    .menu a.active::after {
      transform: scaleX(1);
      opacity: 1;
      height: 3px;
    }

    .hint {
      margin-top: 1.6rem;
      font-size: 0.85rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: rgba(210, 200, 255, 0.62);
      text-shadow: 0 0 12px rgba(139, 91, 255, 0.2);
    }
  </style>
</head>
<body>
  <canvas id="grid" class="bg" aria-hidden="true"></canvas>
  <canvas id="metaballs" class="fx" aria-hidden="true"></canvas>
  <div class="crt" aria-hidden="true"></div>

  <main class="center">
    <section class="panel">
      <h1 class="title">Balatro Lava</h1>
      <p class="subtitle">Psychedelic Probability</p>
      <nav class="menu" aria-label="Primary">
        <a class="active" href="#">Play</a>
        <a href="#">Decks</a>
        <a href="#">Jokers</a>
        <a href="#">Runes</a>
        <a href="#">About</a>
      </nav>
      <div class="hint">Sink into the flow</div>
    </section>
  </main>

  <script>
    (() => {
      const gridCanvas = document.getElementById("grid");
      const gridCtx = gridCanvas.getContext("2d");

      const glCanvas = document.getElementById("metaballs");
      const gl = glCanvas.getContext("webgl", { antialias: true, premultipliedAlpha: true });

      if (!gl) {
        console.error("WebGL not supported.");
        return;
      }

      const MAX_BLOBS = 12;
      const BLOBS = 9;
      const blobs = new Array(BLOBS).fill(0).map((_, i) => {
        const angle = (i / BLOBS) * Math.PI * 2;
        const radius = 0.12 + Math.random() * 0.12;
        const speed = 0.0007 + Math.random() * 0.0009;
        return {
          x: Math.cos(angle) * (0.2 + Math.random() * 0.35),
          y: Math.sin(angle) * (0.2 + Math.random() * 0.35),
          vx: (Math.random() * 2 - 1) * speed,
          vy: (Math.random() * 2 - 1) * speed,
          r: radius,
          wobble: Math.random() * 1000,
        };
      });

      let width = 0;
      let height = 0;
      let dpr = 1;

      function resize() {
        const { innerWidth, innerHeight, devicePixelRatio } = window;
        width = innerWidth;
        height = innerHeight;
        dpr = Math.min(1.75, devicePixelRatio || 1);

        gridCanvas.width = Math.floor(width * dpr);
        gridCanvas.height = Math.floor(height * dpr);
        gridCanvas.style.width = width + "px";
        gridCanvas.style.height = height + "px";
        gridCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

        glCanvas.width = Math.floor(width * dpr);
        glCanvas.height = Math.floor(height * dpr);
        glCanvas.style.width = width + "px";
        glCanvas.style.height = height + "px";
        gl.viewport(0, 0, glCanvas.width, glCanvas.height);
      }

      window.addEventListener("resize", resize, { passive: true });
      resize();

      /* -------------------- Grid Background (2D) -------------------- */
      function drawWavyGrid(t) {
        const time = t * 0.001;
        const w = width;
        const h = height;

        gridCtx.clearRect(0, 0, w, h);
        gridCtx.fillStyle = "rgba(3,3,8,1)";
        gridCtx.fillRect(0, 0, w, h);

        const spacing = Math.max(28, Math.min(56, Math.round(Math.min(w, h) / 22)));
        const ampX = spacing * 0.45;
        const ampY = spacing * 0.35;
        const freqX = 0.012;
        const freqY = 0.014;

        gridCtx.lineWidth = 1.2;
        gridCtx.shadowBlur = 16;
        gridCtx.shadowColor = "rgba(37,246,255,0.15)";

        function strokeLine(color, alpha) {
          gridCtx.strokeStyle = color;
          gridCtx.globalAlpha = alpha;
          gridCtx.stroke();
        }

        // Vertical lines
        for (let x0 = -spacing * 2; x0 < w + spacing * 2; x0 += spacing) {
          gridCtx.beginPath();
          for (let y = -spacing * 2; y < h + spacing * 2; y += 14) {
            const dx =
              Math.sin(y * freqX + time * 1.4 + x0 * 0.004) * ampX * 0.6 +
              Math.sin(y * freqY * 0.6 - time * 0.9) * ampX * 0.25;
            const dy =
              Math.sin(x0 * freqY + time * 0.7 + y * 0.003) * ampY * 0.18;
            const x = x0 + dx;
            const yy = y + dy;
            if (y === -spacing * 2) gridCtx.moveTo(x, yy);
            else gridCtx.lineTo(x, yy);
          }
          strokeLine("rgba(139,91,255,0.85)", 0.18);
          strokeLine("rgba(37,246,255,0.9)", 0.22);
        }

        // Horizontal lines
        for (let y0 = -spacing * 2; y0 < h + spacing * 2; y0 += spacing) {
          gridCtx.beginPath();
          for (let x = -spacing * 2; x < w + spacing * 2; x += 14) {
            const dy =
              Math.sin(x * freqY + time * 1.2 + y0 * 0.0045) * ampY * 0.7 +
              Math.cos(x * freqX * 0.7 - time * 0.8) * ampY * 0.22;
            const dx =
              Math.sin(y0 * freqX - time * 0.6 + x * 0.002) * ampX * 0.16;
            const xx = x + dx;
            const y = y0 + dy;
            if (x === -spacing * 2) gridCtx.moveTo(xx, y);
            else gridCtx.lineTo(xx, y);
          }
          strokeLine("rgba(255,43,214,0.9)", 0.16);
          strokeLine("rgba(37,246,255,0.95)", 0.2);
        }

        gridCtx.globalAlpha = 1;
        gridCtx.shadowBlur = 0;

        // Subtle vignette glow
        const vignette = gridCtx.createRadialGradient(
          w * 0.5, h * 0.5, Math.min(w, h) * 0.15,
          w * 0.5, h * 0.5, Math.max(w, h) * 0.75
        );
        vignette.addColorStop(0, "rgba(0,0,0,0)");
        vignette.addColorStop(1, "rgba(0,0,0,0.55)");
        gridCtx.fillStyle = vignette;
        gridCtx.fillRect(0, 0, w, h);
      }

      /* -------------------- WebGL Metaballs -------------------- */
      const vertexSrc = `
        attribute vec2 a_pos;
        varying vec2 v_uv;
        void main() {
          v_uv = a_pos * 0.5 + 0.5;
          gl_Position = vec4(a_pos, 0.0, 1.0);
        }
      `;

      const fragmentSrc = `
        precision highp float;

        const int MAX_BLOBS = ${MAX_BLOBS};

        varying vec2 v_uv;
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform int u_blobCount;
        uniform vec3 u_blobs[MAX_BLOBS]; // xy in -1..1, z radius

        float hash(vec2 p) {
          return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
        }

        float noise(in vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          float a = hash(i);
          float b = hash(i + vec2(1.0, 0.0));
          float c = hash(i + vec2(0.0, 1.0));
          float d = hash(i + vec2(1.0, 1.0));
          vec2 u = f * f * (3.0 - 2.0 * f);
          return mix(a, b, u.x) +
                 (c - a) * u.y * (1.0 - u.x) +
                 (d - b) * u.x * u.y;
        }

        float metaballField(vec2 p) {
          float sum = 0.0;
          for (int i = 0; i < MAX_BLOBS; i++) {
            if (i >= u_blobCount) break;
            vec3 b = u_blobs[i];
            vec2 d = p - b.xy;
            float dist2 = dot(d, d) + 0.0005;
            float r2 = b.z * b.z;
            sum += r2 / dist2;
          }
          return sum;
        }

        vec3 palette(float t) {
          vec3 deepBlue = vec3(0.06, 0.22, 0.48);
          vec3 teal = vec3(0.08, 0.55, 0.58);
          vec3 olive = vec3(0.42, 0.45, 0.12);
          vec3 slate = vec3(0.14, 0.26, 0.32);
          return deepBlue
               + 0.30 * cos(6.28318 * (vec3(0.12, 0.33, 0.55) + t))
               + 0.18 * teal
               + 0.12 * olive
               + 0.10 * slate;
        }

        void main() {
          vec2 uv = v_uv;
          vec2 p = uv * 2.0 - 1.0;
          p.x *= u_resolution.x / max(u_resolution.y, 1.0);

          // Mild psychedelic warp
          float warp = 0.06 * sin(p.y * 5.0 + u_time * 0.7)
                     + 0.04 * cos(p.x * 6.0 - u_time * 0.5);
          p += vec2(warp * 0.7, warp * 0.35);

          float field = metaballField(p);

          // Surface and glow bands
          float threshold = 1.15;
          float edge = smoothstep(threshold - 0.12, threshold + 0.02, field);
          float core = smoothstep(threshold + 0.18, threshold + 0.75, field);
          float halo = smoothstep(threshold - 0.6, threshold - 0.05, field) - edge;

          float n = noise(uv * 6.0 + u_time * 0.08);
          float t = 0.18 * u_time + field * 0.18 + n * 0.35;
          vec3 col = palette(t);

          // Add electric rim and warm core
          vec3 rim = mix(vec3(0.08, 0.55, 0.75), vec3(0.35, 0.55, 0.2), 0.5 + 0.5 * sin(t * 2.5));
          vec3 warm = vec3(0.55, 0.52, 0.18);

          vec3 color =
              col * edge * 0.85 +
              rim * halo * 0.75 +
              warm * core * 0.55;

          // Soft additive bloom
          float bloom = pow(max(field - (threshold - 0.35), 0.0), 1.8) * 0.03;
          color += col * bloom;

          // Alpha is driven by surface + halo
          float alpha = clamp(edge * 0.9 + halo * 0.6 + core * 0.5, 0.0, 1.0);

          // Fade toward edges of screen
          float vignette = smoothstep(1.35, 0.25, length(p));
          alpha *= vignette;
          color *= vignette;

          gl_FragColor = vec4(color, alpha);
        }
      `;

      function compileShader(type, src) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          const info = gl.getShaderInfoLog(shader);
          gl.deleteShader(shader);
          throw new Error("Shader compile error: " + info);
        }
        return shader;
      }

      function createProgram(vsSrc, fsSrc) {
        const vs = compileShader(gl.VERTEX_SHADER, vsSrc);
        const fs = compileShader(gl.FRAGMENT_SHADER, fsSrc);
        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          const info = gl.getProgramInfoLog(program);
          gl.deleteProgram(program);
          throw new Error("Program link error: " + info);
        }
        gl.deleteShader(vs);
        gl.deleteShader(fs);
        return program;
      }

      const program = createProgram(vertexSrc, fragmentSrc);
      gl.useProgram(program);

      const posLoc = gl.getAttribLocation(program, "a_pos");
      const uResLoc = gl.getUniformLocation(program, "u_resolution");
      const uTimeLoc = gl.getUniformLocation(program, "u_time");
      const uBlobCountLoc = gl.getUniformLocation(program, "u_blobCount");
      const uBlobsLoc = gl.getUniformLocation(program, "u_blobs[0]");

      const quad = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, quad);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([
          -1, -1,
           1, -1,
          -1,  1,
          -1,  1,
           1, -1,
           1,  1,
        ]),
        gl.STATIC_DRAW
      );

      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

      gl.clearColor(0, 0, 0, 0);
      gl.disable(gl.DEPTH_TEST);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

      const blobUniformArray = new Float32Array(MAX_BLOBS * 3);

      let lastTime = 0;

      function updateBlobs(time) {
        const dt = lastTime ? Math.min(0.05, (time - lastTime) / 1000) : 1 / 60;
        const dtScale = dt * 60;
        lastTime = time;
        const t = time * 0.001;
        const aspect = width / Math.max(height, 1);

        for (let i = 0; i < BLOBS; i++) {
          const b = blobs[i];
          const wob = Math.sin(t * 0.9 + b.wobble) * 0.0009;
          const wob2 = Math.cos(t * 0.7 + b.wobble * 1.7) * 0.0007;

          b.vx += wob * 0.12 * dtScale;
          b.vy += wob2 * 0.12 * dtScale;

          // Gentle center pull
          b.vx += (-b.x) * 0.0000025 * dtScale;
          b.vy += (-b.y) * 0.0000025 * dtScale;
        }

        // Pairwise attraction / repulsion for organic merges
        for (let i = 0; i < BLOBS; i++) {
          for (let j = i + 1; j < BLOBS; j++) {
            const a = blobs[i];
            const b = blobs[j];
            let dx = b.x - a.x;
            let dy = b.y - a.y;
            const dist = Math.hypot(dx, dy) + 1e-6;
            dx /= dist;
            dy /= dist;

            const mergeRange = (a.r + b.r) * 2.2;
            const repelRange = (a.r + b.r) * 0.9;

            if (dist < mergeRange) {
              const strength = (mergeRange - dist) * 0.0000045 * dtScale;
              a.vx += dx * strength;
              a.vy += dy * strength;
              b.vx -= dx * strength;
              b.vy -= dy * strength;
            }

            if (dist < repelRange) {
              const strength = (repelRange - dist) * 0.000018 * dtScale;
              a.vx -= dx * strength;
              a.vy -= dy * strength;
              b.vx += dx * strength;
              b.vy += dy * strength;
            }
          }
        }

        // Integrate + boundary bounce in normalized space
        const boundX = 1.05 * aspect;
        const boundY = 1.05;

        for (let i = 0; i < BLOBS; i++) {
          const b = blobs[i];
          b.x += b.vx * dtScale;
          b.y += b.vy * dtScale;

          const damping = Math.pow(0.995, dtScale);
          b.vx *= damping;
          b.vy *= damping;

          if (b.x < -boundX) { b.x = -boundX; b.vx *= -0.92; }
          if (b.x >  boundX) { b.x =  boundX; b.vx *= -0.92; }
          if (b.y < -boundY) { b.y = -boundY; b.vy *= -0.92; }
          if (b.y >  boundY) { b.y =  boundY; b.vy *= -0.92; }

          // Slight breathing radius
          const breath = 0.012 * Math.sin(t * 1.7 + b.wobble * 2.3);
          const rr = Math.max(0.08, Math.min(0.28, b.r + breath));

          const idx = i * 3;
          blobUniformArray[idx + 0] = b.x;
          blobUniformArray[idx + 1] = b.y;
          blobUniformArray[idx + 2] = rr;
        }
      }

      function render(time) {
        drawWavyGrid(time);

        updateBlobs(time);

        gl.viewport(0, 0, glCanvas.width, glCanvas.height);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.uniform2f(uResLoc, glCanvas.width, glCanvas.height);
        gl.uniform1f(uTimeLoc, time * 0.001);
        gl.uniform1i(uBlobCountLoc, BLOBS);
        gl.uniform3fv(uBlobsLoc, blobUniformArray);

        gl.drawArrays(gl.TRIANGLES, 0, 6);

        requestAnimationFrame(render);
      }

      requestAnimationFrame(render);
    })();
  </script>
</body>
</html>
