<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wormhole Zoom</title>
    <style>
body, html {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background-color: #000;
    font-family: 'Courier New', Courier, monospace;
}

#scene {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
}

.layer {
    position: absolute;
    width: 100vmax; /* Use vmax to ensure coverage */
    height: 100vmax;
    display: flex;
    justify-content: center;
    align-items: center;
    will-change: transform;
}

/* The visual content of the layer */
.texture {
    position: absolute;
    width: 100%;
    height: 100%;
    background-position: center;
    background-size: cover;
}

/*
   We need a hole in the center.
   We can use mask-image or a thick border.
   A thick border is easier to render performantly than masks sometimes,
   but mask-image is cleaner for "portal" effects.
   Let's use a radial-gradient mask to cut a hole in the center.
   Transparent in the middle, opaque outside.
*/
.mask {
    position: absolute;
    width: 100%;
    height: 100%;
    /* The hole is 20% of the size */
    -webkit-mask-image: radial-gradient(circle at center, transparent 10%, black 10.5%);
    mask-image: radial-gradient(circle at center, transparent 10%, black 10.5%);
}

/* Optional: Add some decoration around the hole */
.rim {
    position: absolute;
    width: 21%; /* Just outside the 20% hole (10% radius = 20% diameter) */
    height: 21%;
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.5);
    box-shadow: 0 0 20px currentColor;
    opacity: 0.8;
}

#vignette {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    background: radial-gradient(circle, transparent 30%, rgba(0,0,0,0.8) 90%, black 100%);
    z-index: 100;
}

#glow {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: white;
    filter: blur(20px);
    mix-blend-mode: screen;
    pointer-events: none;
    z-index: 101;
    transition: background-color 0.5s;
}

#ui {
    position: fixed;
    bottom: 20px;
    left: 20px;
    color: white;
    z-index: 102;
    background: rgba(0,0,0,0.5);
    padding: 10px;
    border-radius: 8px;
}
    </style>
</head>
<body>
    <div id="scene">
        <!-- Layers will be managed by JS -->
    </div>

    <!-- Vignette overlay to darken edges -->
    <div id="vignette"></div>

    <!-- Pulsing glow at center -->
    <div id="glow"></div>

    <div id="ui">
        <p>Speed: <input type="range" id="speed" min="0" max="5" step="0.1" value="1"></p>
    </div>

    <script>
const scene = document.getElementById('scene');
const glow = document.getElementById('glow');
const speedInput = document.getElementById('speed');

// Configuration
const PORTAL_RATIO = 0.2; // The portal is 20% of the layer size (0.1 radius * 2)
// If mask is transparent 10% (radius), then diameter is 20%.
// So the scaling factor between layers must be 1 / 0.2 = 5.
const SCALE_FACTOR = 5;
const LAYERS_COUNT = 6;
let currentZoom = 1;
let speed = 1;

// Colors for the theme
const palettes = [
    ['#1a0b2e', '#4f2c82', '#0d0d0d'], // Purple Void
    ['#001f3f', '#0074D9', '#000000'], // Deep Sea
    ['#2E0B0B', '#822C2C', '#100000'], // Crimson Core
    ['#0B2E1E', '#2C8256', '#001005'], // Emerald Matrix
    ['#2E250B', '#82702C', '#100C00'], // Gold Dust
];

let layerIndex = 0;
const layers = [];

function createLayer(index) {
    const layer = document.createElement('div');
    layer.classList.add('layer');

    // Create generative art content
    const texture = document.createElement('div');
    texture.classList.add('texture');
    texture.classList.add('mask');

    // Pick a palette
    const palette = palettes[index % palettes.length];
    const mainColor = palette[0];
    const accentColor = palette[1];
    const darkColor = palette[2];

    // Generative CSS pattern
    const patternType = Math.floor(Math.random() * 3);

    if (patternType === 0) {
        // Radial Grid
        texture.style.background = `
            repeating-radial-gradient(
                circle at center,
                ${darkColor} 0%,
                ${mainColor} 10%,
                ${darkColor} 20%
            )
        `;
    } else if (patternType === 1) {
        // Conic Rays
        texture.style.background = `
            conic-gradient(
                from 0deg,
                ${darkColor},
                ${accentColor} 20deg,
                ${darkColor} 40deg,
                ${mainColor} 60deg,
                ${darkColor} 80deg
            )
        `;
        texture.style.backgroundSize = 'cover';
    } else {
        // Checker/Geometric
        texture.style.background = `
            repeating-conic-gradient(${darkColor} 0% 25%, ${accentColor} 0% 50%)
            50% / 20% 20%
        `;
    }

    // Add some random stars or debris
    // For performance, we can just use another gradient layer
    const stars = `radial-gradient(white 1px, transparent 1px)`;
    texture.style.backgroundImage += `, ${stars}`;
    texture.style.backgroundSize += `, 50px 50px`;

    // Rim
    const rim = document.createElement('div');
    rim.classList.add('rim');
    rim.style.color = accentColor;

    layer.appendChild(texture);
    layer.appendChild(rim);

    return { element: layer, palette: palette, index: index };
}

function init() {
    for (let i = 0; i < LAYERS_COUNT; i++) {
        addLayerAtBack();
    }
    animate();
}

let rotationOffset = 0;

function addLayerAtBack() {
    const layerObj = createLayer(layerIndex++);
    scene.appendChild(layerObj.element);
    layers.push(layerObj);
}

function removeFrontLayer() {
    const layerObj = layers.shift();
    if (layerObj && layerObj.element.parentNode) {
        layerObj.element.parentNode.removeChild(layerObj.element);
    }
}

// Update loop
function animate() {
    speed = parseFloat(speedInput.value);

    // Increase zoom exponentially
    // Delta zoom
    const zoomStep = 1 + (0.01 * speed);
    currentZoom *= zoomStep;

    // Check if we completed a cycle
    if (currentZoom >= SCALE_FACTOR) {
        // We zoomed in by SCALE_FACTOR.
        // Layer 1 is now size of Layer 0.
        // Reset zoom but shift layers
        currentZoom /= SCALE_FACTOR;
        removeFrontLayer();
        addLayerAtBack();
    }

    rotationOffset += 0.5 * speed;

    // Update glow color based on the current "inner" layer (Layer 0 is surrounding us, Layer 1 is the target)
    // Actually Layer 0 is the one surrounding, Layer 1 is the destination.
    // Let's pulse the glow color based on the upcoming layer
    if (layers[1]) {
        glow.style.backgroundColor = layers[1].palette[1];
        glow.style.boxShadow = `0 0 ${20 + Math.sin(Date.now() / 200) * 10}px ${layers[1].palette[1]}`;
    }

    // Render layers
    // Layer 0 scale = currentZoom
    // Layer 1 scale = currentZoom / SCALE_FACTOR
    // Layer i scale = currentZoom / (SCALE_FACTOR ^ i)

    for (let i = 0; i < layers.length; i++) {
        const layer = layers[i].element;
        // Calculate scale
        // The first layer (i=0) starts at 1 and goes to SCALE_FACTOR
        // The second layer (i=1) starts at 1/SCALE_FACTOR and goes to 1
        const scale = currentZoom / Math.pow(SCALE_FACTOR, i);

        // Visibility optimization
        if (scale < 0.001) {
             layer.style.display = 'none';
        } else {
             layer.style.display = 'flex';
             // Use the layer's original index to maintain consistent spiral rotation
             // Twist factor: 30 degrees per layer
             const spiralPhase = layers[i].index * 30;
             const totalRotation = rotationOffset + spiralPhase;
             layer.style.transform = `scale(${scale}) rotate(${totalRotation}deg)`;
        }
    }

    requestAnimationFrame(animate);
}

init();
    </script>
</body>
</html>
