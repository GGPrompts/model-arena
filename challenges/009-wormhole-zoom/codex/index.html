<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wormhole Zoom</title>
  <style>
    :root {
      --bg0: #04050a;
      --bg1: #0b1326;
      --ink: #c9f4ff;
      --glow: #7cffc6;
      --accent: #9cf5ff;
      --accent2: #56b6ff;
      --ion: #7cffc6;
      --ion2: #cffff4;
    }
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      background: radial-gradient(120% 120% at 50% 40%, var(--bg1), var(--bg0));
      overflow: hidden;
      font-family: "Trebuchet MS", "Lucida Sans Unicode", "Lucida Grande", "Lucida Sans", Arial, sans-serif;
      color: var(--ink);
    }
    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
      filter: saturate(1.2) contrast(1.05);
    }
    .hud {
      position: fixed;
      left: 24px;
      bottom: 22px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      font-size: 12px;
      opacity: 0.7;
      mix-blend-mode: screen;
      text-shadow: 0 0 12px rgba(124, 255, 198, 0.45);
      user-select: none;
      pointer-events: none;
    }
    .hint {
      position: fixed;
      right: 24px;
      bottom: 22px;
      font-size: 11px;
      opacity: 0.55;
      user-select: none;
      pointer-events: none;
    }
    .reticle {
      position: fixed;
      inset: 0;
      pointer-events: none;
      mix-blend-mode: screen;
      opacity: 0.35;
    }
    .reticle::before,
    .reticle::after {
      content: "";
      position: absolute;
      left: 50%;
      top: 50%;
      width: 36vmin;
      height: 36vmin;
      border: 1px solid rgba(124, 255, 198, 0.4);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 30px rgba(124, 255, 198, 0.25), inset 0 0 25px rgba(124, 255, 198, 0.25);
      animation: pulse 6s ease-in-out infinite;
    }
    .reticle::after {
      width: 18vmin;
      height: 18vmin;
      border-color: rgba(156, 245, 255, 0.45);
      animation-delay: -3s;
    }
    @keyframes pulse {
      0%, 100% { transform: translate(-50%, -50%) scale(0.98); opacity: 0.5; }
      50% { transform: translate(-50%, -50%) scale(1.02); opacity: 0.9; }
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hud">ion cannon array</div>
  <div class="hint">aim to steer the beam</div>
  <div class="reticle"></div>

  <script>
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");

    const buffer = document.createElement("canvas");
    const bctx = buffer.getContext("2d");

    const pointer = { x: 0.5, y: 0.5, targetX: 0.5, targetY: 0.5 };

    function resize() {
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      buffer.width = canvas.width;
      buffer.height = canvas.height;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      bctx.setTransform(1, 0, 0, 1, 0, 0);
    }

    window.addEventListener("resize", resize);
    window.addEventListener("mousemove", (e) => {
      pointer.targetX = e.clientX / window.innerWidth;
      pointer.targetY = e.clientY / window.innerHeight;
    });
    window.addEventListener("touchmove", (e) => {
      if (!e.touches.length) return;
      pointer.targetX = e.touches[0].clientX / window.innerWidth;
      pointer.targetY = e.touches[0].clientY / window.innerHeight;
    }, { passive: true });

    resize();

    function drawStarfield(t) {
      const w = canvas.width;
      const h = canvas.height;
      const count = 220;
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      for (let i = 0; i < count; i++) {
        const n = i / count;
        const angle = n * Math.PI * 12 + t * 0.02;
        const radius = (n ** 2) * Math.max(w, h) * 0.6;
        const x = w * 0.5 + Math.cos(angle) * radius + Math.sin(t * 0.002 + n) * 22;
        const y = h * 0.5 + Math.sin(angle) * radius + Math.cos(t * 0.002 + n) * 22;
        const twinkle = 0.3 + 0.7 * Math.sin(t * 0.003 + i) ** 2;
        ctx.fillStyle = `rgba(170, 255, 220, ${0.25 + twinkle * 0.5})`;
        ctx.fillRect(x, y, 1.2 + twinkle * 1.5, 1.2 + twinkle * 1.5);
      }
      ctx.restore();
    }

    function drawRings(t) {
      const w = canvas.width;
      const h = canvas.height;
      ctx.save();
      ctx.translate(w * 0.5, h * 0.5);
      ctx.rotate(t * 0.0003);
      ctx.globalCompositeOperation = "screen";
      for (let i = 0; i < 8; i++) {
        const progress = (t * 0.0004 + i / 8) % 1;
        const radius = progress * Math.min(w, h) * 0.48 + 40;
        ctx.beginPath();
        ctx.strokeStyle = `rgba(124, 255, 198, ${0.5 - progress * 0.45})`;
        ctx.lineWidth = 2 + (1 - progress) * 6;
        ctx.ellipse(0, 0, radius, radius * (0.7 + 0.2 * Math.sin(t * 0.0007 + i)), 0, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawBeam(t) {
      const w = canvas.width;
      const h = canvas.height;
      const ox = (pointer.x - 0.5) * w * 0.2;
      const oy = (pointer.y - 0.5) * h * 0.2;
      ctx.save();
      ctx.translate(w * 0.5 + ox, h * 0.5 + oy);
      ctx.globalCompositeOperation = "screen";
      const grad = ctx.createLinearGradient(0, -h * 0.6, 0, h * 0.6);
      grad.addColorStop(0, "rgba(124,255,198,0)");
      grad.addColorStop(0.45, "rgba(124,255,198,0.15)");
      grad.addColorStop(0.5, "rgba(207,255,244,0.6)");
      grad.addColorStop(0.55, "rgba(124,255,198,0.15)");
      grad.addColorStop(1, "rgba(124,255,198,0)");
      ctx.fillStyle = grad;
      const beamW = Math.min(w, h) * (0.16 + 0.02 * Math.sin(t * 0.002));
      ctx.beginPath();
      ctx.ellipse(0, 0, beamW, h * 0.7, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawPortal(t) {
      const w = canvas.width;
      const h = canvas.height;
      const ox = (pointer.x - 0.5) * w * 0.18;
      const oy = (pointer.y - 0.5) * h * 0.18;
      ctx.save();
      ctx.translate(w * 0.5 + ox, h * 0.5 + oy);
      const grad = ctx.createRadialGradient(0, 0, 10, 0, 0, Math.min(w, h) * 0.35);
      grad.addColorStop(0, "rgba(255,255,255,0.7)");
      grad.addColorStop(0.2, "rgba(156,245,255,0.4)");
      grad.addColorStop(0.55, "rgba(86,182,255,0.2)");
      grad.addColorStop(0.95, "rgba(5,6,15,0.0)");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.ellipse(0, 0, Math.min(w, h) * 0.32, Math.min(w, h) * 0.26, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawNebula(t) {
      const w = canvas.width;
      const h = canvas.height;
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      for (let i = 0; i < 14; i++) {
        const n = i / 14;
        const x = w * (0.2 + 0.6 * Math.sin(t * 0.0002 + n * 3));
        const y = h * (0.2 + 0.6 * Math.cos(t * 0.00022 + n * 2));
        const r = Math.min(w, h) * (0.08 + n * 0.03);
        const grad = ctx.createRadialGradient(x, y, r * 0.1, x, y, r);
        grad.addColorStop(0, `rgba(156,245,255, ${0.12 + n * 0.05})`);
        grad.addColorStop(1, "rgba(5,6,15,0)");
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function step(t) {
      pointer.x += (pointer.targetX - pointer.x) * 0.02;
      pointer.y += (pointer.targetY - pointer.y) * 0.02;

      const w = canvas.width;
      const h = canvas.height;

      const base = ctx.createLinearGradient(0, 0, w, h);
      base.addColorStop(0, "#05060f");
      base.addColorStop(0.55, "#0b1b2f");
      base.addColorStop(1, "#04040b");
      ctx.fillStyle = base;
      ctx.fillRect(0, 0, w, h);

      drawNebula(t);

      const s = 0.975 + Math.sin(t * 0.0006) * 0.008;
      const rot = Math.sin(t * 0.0004) * 0.008;
      const ox = (pointer.x - 0.5) * w * 0.12;
      const oy = (pointer.y - 0.5) * h * 0.12;

      ctx.save();
      ctx.translate(w * 0.5 + ox, h * 0.5 + oy);
      ctx.rotate(rot);
      ctx.scale(s, s);
      ctx.translate(-w * 0.5, -h * 0.5);
      ctx.globalAlpha = 0.98;
      ctx.globalCompositeOperation = "screen";
      ctx.drawImage(buffer, 0, 0, w, h);
      ctx.restore();

      ctx.save();
      ctx.globalCompositeOperation = "screen";
      for (let i = 0; i < 3; i++) {
        ctx.save();
        ctx.translate(w * 0.5, h * 0.5);
        ctx.rotate(t * 0.0002 + i * (Math.PI * 2 / 3));
        ctx.scale(0.65, 0.65);
        ctx.translate(-w * 0.5, -h * 0.5);
        ctx.globalAlpha = 0.15;
        ctx.drawImage(buffer, 0, 0, w, h);
        ctx.restore();
      }
      ctx.restore();

      drawStarfield(t);
      drawBeam(t);
      drawRings(t);
      drawPortal(t);

      bctx.clearRect(0, 0, w, h);
      bctx.globalCompositeOperation = "source-over";
      bctx.drawImage(canvas, 0, 0, w, h);

      requestAnimationFrame(step);
    }

    ctx.fillStyle = "#05060f";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    bctx.drawImage(canvas, 0, 0);
    requestAnimationFrame(step);
  </script>
</body>
</html>
